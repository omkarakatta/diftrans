% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/computingOT.R
\name{get_OTcost}
\alias{get_OTcost}
\title{Compute Optimal Transport Cost}
\usage{
get_OTcost(
  pre_df,
  post_df,
  bandwidth = 0,
  var = MSRP,
  count = count,
  costmat = NULL,
  costmat_ref = NULL,
  scale_pre = "default",
  scale_post = "default",
  total = 1
)
}
\arguments{
\item{pre_df}{A two-column \code{data.frame} describing the pre-distribution;}

\item{post_df}{A two-column \code{data.frame} describing the
post-distribution;}

\item{bandwidth}{A non-negative number to ignore small transfers;
defaults to 0}

\item{var}{The title of the column of support values in \code{pre_df}
and \code{post_df}; defaults to \code{MSRP}}

\item{count}{The title of the column of masses in \code{pre_df}
and \code{post_df}; defaults to \code{count}}

\item{costmat}{The cost matrix to be fed to
\code{\link[transport]{transport}}}

\item{costmat_ref}{The cost matrix that is used to reference output of
code{\link[transport]{transport}}}

\item{scale_pre, scale_post}{The scaling factor of the counts to be used in
the \code{\link[transport]{transport}} function; defaults to "default",
which scales the counts in the pre-distribution to sum to the total of
the counts in the post-distribution; can also be "subsample"}

\item{total}{The total mass count for subsample scaling}
}
\value{
A list of the total mass transferred (\code{tot_cost}),
the proportion of mass transferred (\code{prop_cost}), and the
\code{bandwidth}
}
\description{
Compute the percentage of mass that has moved more than
\code{bandwidth} units away on the support of two discrete
distributions, \code{pre_df} and \code{post_df}.
}
\details{
The pre- and post-distributions given by \code{pre_df}
and \code{post_df} need to be \code{data.frame} objects of
two columns. The first column whose title should be given by
\code{var} contains the common support of the two distributions.
In other words, the values in \code{var} in each \code{pre_df}
and \code{post_df} need to be unique and the same across the two
distributions.
The second column named \code{count} provides the mass on the
respective value of the support.
If the sum of \code{count} in each \code{pre_df} and \code{post_df} is 1,
then \code{pre_df} and \code{post_df} are probability mass functions.

The \code{bandwidth} argument should be a non-negative number.
If mass is transferred less than \code{bandwidth}, we ignore these transfers.
Otherwise, we place equal weight on the transfers.
Resultantly, the output of this function is the percentage of mass
that has been tranferred more than \code{bandwidth} units between
\code{pre_df} and \code{post_df}.

Instead of the default cost function that uses \code{bandwidth},
\code{costmat}, and \code{costmat_ref} can be used to specify the
cost matrix of choice.
The first matrix is fed into \code{\link[transport]{transport}} function from
the \code{transport} package and may use the common support of
\code{pre_df} and \code{post_df}.
The second matrix \code{costmat_ref} is used to interpret the output
of the \code{\link[transport]{transport}} function. It uses the
the minimal support of \code{pre_df} along the rows and the
minimal support of \code{post_df} along the columns.

This function does minimal error-checking, but good practices include:
\enumerate{
\item non-degenerate pre- and post-distributions
\item non-negative values for \code{bandwidth}
\item if not NULL, \code{costmat} should be a square matrix
whose dimension is the length of the common support
\item if not NULL, \code{costmat_ref} should be a matrix
whose dimension is the length of the support of \code{pre_df}
by the length of the support of \code{post_df}
}

When fed into \code{\link{transport}}, the pre- and post-distribution
counts will be scaled so they sum to the total in the post-distribution.
This is when we scale using the "default" process.
If we scale using the "subsample" process, then we ensure that regardless
of the subsample size, the total in the pre- and post-distributions for
the subsample is equal to \code{total}.
}
\examples{
\dontrun{
support <- c(1, 2, 10)
#~ Example 1: complete overlap => 0\% transport cost for any bandwidth
overlap_before <- data.frame(x = support, mass = c(6, 2, 0))
overlap_after <- data.frame(x = support, mass = c(3, 1, 0))
get_OTcost(overlap_before, overlap_after,
           var = x, count = mass)
get_OTcost(overlap_before, overlap_after,
           var = x, count = mass, bandwidth = 2)
#~ Example 2: illustrative example in Daljord et al. (2021)
mix_before <- data.frame(x = support, mass = c(6, 2, 0))
mix_after <- data.frame(x = support, mass = c(1, 3, 0))
get_OTcost(mix_before, mix_after, var = x, count = mass)
}

}
